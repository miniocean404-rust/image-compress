/* auto-generated by NAPI-RS */
/* eslint-disable */
export declare const enum AlphaColorMode {
  /** Use unassociated alpha channel and leave color channels unchanged, even if there's redundant color data in transparent areas. */
  UnassociatedDirty = 'UnassociatedDirty',
  /** Use unassociated alpha channel, but set color channels of transparent areas to a solid color to eliminate invisible data and improve compression. */
  UnassociatedClean = 'UnassociatedClean',
  /**
   * Store color channels of transparent images in premultiplied form.
   * This requires support for premultiplied alpha in AVIF decoders.
   *
   * It may reduce file sizes due to clearing of fully-transparent pixels, but
   * may also increase file sizes due to creation of new edges in the color channels.
   *
   * Note that this is only internal detail for the AVIF file.
   * It does not change meaning of `RGBA` in this library — it's always unassociated.
   */
  Premultiplied = 'Premultiplied'
}

export interface AvifOptions {
  /** 质量 `1..=100` */
  quality: number
  /** Alpha 通道的独立质量 `1..=100` */
  alphaQuality?: number
  /**
   * 压缩速度 (effort) `1..=10`
   *
   * 1 = 非常非常慢，但是最大的压缩
   * 10 = 快速，但文件大小较大，质量较差。
   */
  speed: number
  /**
   * 更改图像中颜色通道的存储方式。
   *
   * 请注意，这只是AVIF文件的内部细节，不会改变编码函数输入的颜色空间。
   */
  colorSpace: ColorSpace
  /** 配置透明图像中颜色通道的处理 */
  alphaColorMode: AlphaColorMode
}

export declare const enum ColorSpace {
  /** error/unspecified */
  JCS_UNKNOWN = 'JCS_UNKNOWN',
  /** monochrome */
  JCS_GRAYSCALE = 'JCS_GRAYSCALE',
  /** red/green/blue as specified by the `RGB_RED`, `RGB_GREEN`, `RGB_BLUE`, and `RGB_PIXELSIZE` macros */
  JCS_RGB = 'JCS_RGB',
  /** Y/Cb/Cr (also known as YUV) */
  JCS_YCbCr = 'JCS_YCbCr',
  /** C/M/Y/K */
  JCS_CMYK = 'JCS_CMYK',
  /** Y/Cb/Cr/K */
  JCS_YCCK = 'JCS_YCCK',
  /** red/green/blue */
  JCS_EXT_RGB = 'JCS_EXT_RGB',
  /**
   * red/green/blue/x
   * When `out_color_space` it set to `JCS_EXT_RGBX`, `JCS_EXT_BGRX`, `JCS_EXT_XBGR`,
   * or `JCS_EXT_XRGB` during decompression, the X byte is undefined, and in
   * order to ensure the best performance, libjpeg-turbo can set that byte to
   * whatever value it wishes.
   */
  JCS_EXT_RGBX = 'JCS_EXT_RGBX',
  /** blue/green/red */
  JCS_EXT_BGR = 'JCS_EXT_BGR',
  /** blue/green/red/x */
  JCS_EXT_BGRX = 'JCS_EXT_BGRX',
  /** x/blue/green/red */
  JCS_EXT_XBGR = 'JCS_EXT_XBGR',
  /** x/red/green/blue */
  JCS_EXT_XRGB = 'JCS_EXT_XRGB',
  /**
   * Use the following colorspace constants to
   * ensure that the X byte is set to 0xFF, so that it can be interpreted as an
   * opaque alpha channel.
   *
   * red/green/blue/alpha
   */
  JCS_EXT_RGBA = 'JCS_EXT_RGBA',
  /** blue/green/red/alpha */
  JCS_EXT_BGRA = 'JCS_EXT_BGRA',
  /** alpha/blue/green/red */
  JCS_EXT_ABGR = 'JCS_EXT_ABGR',
  /** alpha/red/green/blue */
  JCS_EXT_ARGB = 'JCS_EXT_ARGB',
  /** 5-bit red/6-bit green/5-bit blue */
  JCS_RGB565 = 'JCS_RGB565'
}

export declare const enum ColorSpace {
  /**
   * Standard color space for photographic content. Usually the best choice.
   * This library always uses full-resolution color (4:4:4).
   * This library will automatically choose between BT.601 or BT.709.
   */
  YCbCr = 'YCbCr',
  /**
   * RGB channels are encoded without colorspace transformation.
   * Usually results in larger file sizes, and is less compatible than `YCbCr`.
   * Use only if the content really makes use of RGB, e.g. anaglyph images or RGB subpixel anti-aliasing.
   */
  RGB = 'RGB'
}

export interface CompressInfo {
  ext: Kind
  beforeSize: bigint
  afterSize: bigint
  rate: number
  compressedImage: Buffer
}

| { type2: 'Libdeflater', /** 对文件使用哪个压缩级别 （1-12） */
compression: number }

export interface ImageQuantOptions {
  minQuality: number
  maxQuality: number
  speed: number
  minPosterization: number
  dithering: number
  gamma: number
  lastIndexTransparent: boolean
}

export declare function initCustomTraceSubscriber(traceOutFilePath?: string | undefined | null): void

export declare const enum Interlacing {
  None = 'None',
  Adam7 = 'Adam7'
}

export declare const enum Kind {
  jpeg = 'jpeg',
  png = 'png',
  gif = 'gif',
  webp = 'webp',
  avif = 'avif',
  unknown = 'unknown'
}

export interface MozJpegOptions {
  /** 质量, 推荐 60-80. 范围：`1..=100` */
  quality: number
  /** 设置图像的渐进模式 */
  progressive: boolean
  /** 设置为 false 可以毫无理由地使文件变大 */
  optimizeCoding: boolean
  /** 非 0 （1..=100） 它将使用MozJPEG的平滑。 */
  smoothing: number
  /** 设置正在写入的 JPEG 的颜色空间，不同于输入的颜色空间 */
  colorSpace: ColorSpace
  /** 指定在网格量化期间是否应考虑多次扫描。 */
  trellisMultipass: boolean
  /** 设置色度子采样，保留为“None”以使用自动子采样 */
  chromaSubsample?: number
  /** 是否使用特定的量化表。替代质量（quality）设置。 */
  luma: boolean
  /** 是否使用特定的量化表的颜色。替代质量（quality）设置。 */
  chroma: boolean
  qtable?: QtableOptimize
}

export interface OxiPngOptions {
  /**
   * Attempt to fix errors when decoding the input file rather than returning an `Err`.
   *
   * Default: `false`
   */
  fixErrors: boolean
  /**
   * Write to output even if there was no improvement in compression.
   *
   * Default: `false`
   */
  force: boolean
  /**
   * Which RowFilters to try on the file
   *
   * Default: `None,Sub,Entropy,Bigrams`
   */
  filter: RowFilter
  /**
   * Whether to change the interlacing type of the file.
   *
   * `None` will not change the current interlacing type.
   *
   * `Some(x)` will change the file to interlacing mode `x`.
   *
   * Default: `Some(Interlacing::None)`
   */
  interlace?: Interlacing
  /** Whether to allow transparent pixels to be altered to improve compression. */
  optimizeAlpha: boolean
  /**
   * Whether to attempt bit depth reduction
   *
   * Default: `true`
   */
  bitDepthReduction: boolean
  /**
   * Whether to attempt color type reduction
   *
   * Default: `true`
   */
  colorTypeReduction: boolean
  /**
   * Whether to attempt palette reduction
   *
   * Default: `true`
   */
  paletteReduction: boolean
  /**
   * Whether to attempt grayscale reduction
   *
   * Default: `true`
   */
  grayscaleReduction: boolean
  /**
   * Whether to perform recoding of IDAT and other compressed chunks
   *
   * If any type of reduction is performed, IDAT recoding will be performed
   * regardless of this setting
   *
   * Default: `true`
   */
  idatRecoding: boolean
  /**
   * Whether to forcibly reduce 16-bit to 8-bit by scaling
   *
   * Default: `false`
   */
  scale16: boolean
  /**
   * Which chunks to strip from the PNG file, if any
   *
   * Default: `None`
   */
  strip: StripChunks
  /**
   * Which DEFLATE algorithm to use
   *
   * Default: `Libdeflater`
   */
  deflate: Deflaters
  /**
   * Whether to use fast evaluation to pick the best filter
   *
   * Default: `true`
   */
  fastEvaluation: boolean
  /**
   * Maximum amount of time to spend on optimizations.
   * Further potential optimizations are skipped if the timeout is exceeded.
   */
  timeout?: bigint
}

export declare const enum QtableOptimize {
  AhumadaWatsonPeterson = 'AhumadaWatsonPeterson',
  AnnexK_Luma = 'AnnexK_Luma',
  Flat = 'Flat',
  KleinSilversteinCarney = 'KleinSilversteinCarney',
  MSSSIM_Luma = 'MSSSIM_Luma',
  NRobidoux = 'NRobidoux',
  PSNRHVS_Luma = 'PSNRHVS_Luma',
  PetersonAhumadaWatson = 'PetersonAhumadaWatson',
  WatsonTaylorBorthwick = 'WatsonTaylorBorthwick'
}

export declare const enum RowFilter {
  None = 'None',
  Sub = 'Sub',
  Up = 'Up',
  Average = 'Average',
  Paeth = 'Paeth',
  MinSum = 'MinSum',
  Entropy = 'Entropy',
  Bigrams = 'Bigrams',
  BigEnt = 'BigEnt',
  Brute = 'Brute'
}

| { type2: 'None' }
| { type2: 'Strip', field0: unknown[] }
| { type2: 'Safe' }
| { type2: 'Keep', field0: unknown[] }
| { type2: 'All' }

export declare const enum WebPImageHint {
  WEBP_HINT_DEFAULT = 0,
  WEBP_HINT_PICTURE = 1,
  WEBP_HINT_PHOTO = 2,
  WEBP_HINT_GRAPH = 3,
  WEBP_HINT_LAST = 4
}

export interface WebPOptions {
  lossless: number
  quality: number
  method: number
  imageHint: WebPImageHint
  targetSize: number
  targetPsnr: number
  segments: number
  snsStrength: number
  filterStrength: number
  filterSharpness: number
  filterType: number
  autofilter: number
  alphaCompression: number
  alphaFiltering: number
  alphaQuality: number
  pass: number
  showCompressed: number
  preprocessing: number
  partitions: number
  partitionLimit: number
  emulateJpegSize: number
  threadLevel: number
  lowMemory: number
  nearLossless: number
  exact: number
  useDeltaPalette: number
  useSharpYuv: number
  qmin: number
  qmax: number
}

