/* auto-generated by NAPI-RS */
/* eslint-disable */
export declare const enum AlphaColorMode {
  /** Use unassociated alpha channel and leave color channels unchanged, even if there's redundant color data in transparent areas. */
  UnassociatedDirty = 'UnassociatedDirty',
  /** Use unassociated alpha channel, but set color channels of transparent areas to a solid color to eliminate invisible data and improve compression. */
  UnassociatedClean = 'UnassociatedClean',
  /**
   * Store color channels of transparent images in premultiplied form.
   * This requires support for premultiplied alpha in AVIF decoders.
   *
   * It may reduce file sizes due to clearing of fully-transparent pixels, but
   * may also increase file sizes due to creation of new edges in the color channels.
   *
   * Note that this is only internal detail for the AVIF file.
   * It does not change meaning of `RGBA` in this library — it's always unassociated.
   */
  Premultiplied = 'Premultiplied'
}

export interface AvifOptions {
  /** 质量 `1..=100` */
  quality: number
  /** Alpha 通道的独立质量 `1..=100` */
  alphaQuality?: number
  /**
   * 压缩速度 (effort) `1..=10`
   *
   * 1 = 非常非常慢，但是最大的压缩
   * 10 = 快速，但文件大小较大，质量较差。
   */
  speed: number
  /**
   * 更改图像中颜色通道的存储方式。
   *
   * 请注意，这只是AVIF文件的内部细节，不会改变编码函数输入的颜色空间。
   */
  colorSpace: ColorSpace
  /** 配置透明图像中颜色通道的处理 */
  alphaColorMode: AlphaColorMode
}

export declare const enum ColorSpace {
  /** error/unspecified */
  JCS_UNKNOWN = 'JCS_UNKNOWN',
  /** monochrome */
  JCS_GRAYSCALE = 'JCS_GRAYSCALE',
  /** red/green/blue as specified by the `RGB_RED`, `RGB_GREEN`, `RGB_BLUE`, and `RGB_PIXELSIZE` macros */
  JCS_RGB = 'JCS_RGB',
  /** Y/Cb/Cr (also known as YUV) */
  JCS_YCbCr = 'JCS_YCbCr',
  /** C/M/Y/K */
  JCS_CMYK = 'JCS_CMYK',
  /** Y/Cb/Cr/K */
  JCS_YCCK = 'JCS_YCCK',
  /** red/green/blue */
  JCS_EXT_RGB = 'JCS_EXT_RGB',
  /**
   * red/green/blue/x
   * When `out_color_space` it set to `JCS_EXT_RGBX`, `JCS_EXT_BGRX`, `JCS_EXT_XBGR`,
   * or `JCS_EXT_XRGB` during decompression, the X byte is undefined, and in
   * order to ensure the best performance, libjpeg-turbo can set that byte to
   * whatever value it wishes.
   */
  JCS_EXT_RGBX = 'JCS_EXT_RGBX',
  /** blue/green/red */
  JCS_EXT_BGR = 'JCS_EXT_BGR',
  /** blue/green/red/x */
  JCS_EXT_BGRX = 'JCS_EXT_BGRX',
  /** x/blue/green/red */
  JCS_EXT_XBGR = 'JCS_EXT_XBGR',
  /** x/red/green/blue */
  JCS_EXT_XRGB = 'JCS_EXT_XRGB',
  /**
   * Use the following colorspace constants to
   * ensure that the X byte is set to 0xFF, so that it can be interpreted as an
   * opaque alpha channel.
   *
   * red/green/blue/alpha
   */
  JCS_EXT_RGBA = 'JCS_EXT_RGBA',
  /** blue/green/red/alpha */
  JCS_EXT_BGRA = 'JCS_EXT_BGRA',
  /** alpha/blue/green/red */
  JCS_EXT_ABGR = 'JCS_EXT_ABGR',
  /** alpha/red/green/blue */
  JCS_EXT_ARGB = 'JCS_EXT_ARGB',
  /** 5-bit red/6-bit green/5-bit blue */
  JCS_RGB565 = 'JCS_RGB565'
}

export declare const enum ColorSpace {
  /**
   * Standard color space for photographic content. Usually the best choice.
   * This library always uses full-resolution color (4:4:4).
   * This library will automatically choose between BT.601 or BT.709.
   */
  YCbCr = 'YCbCr',
  /**
   * RGB channels are encoded without colorspace transformation.
   * Usually results in larger file sizes, and is less compatible than `YCbCr`.
   * Use only if the content really makes use of RGB, e.g. anaglyph images or RGB subpixel anti-aliasing.
   */
  RGB = 'RGB'
}

export declare function compress(file: string, options: MozJpegOptions | OxiPngOptions | ImageQuantOptions | WebPOptions | AvifOptions): CompressInfo

export interface CompressInfo {
  ext: Kind
  beforeSize: bigint
  afterSize: bigint
  rate: number
  compressedImage: Buffer
}

| { type2: 'Libdeflater', /** 对文件使用哪个压缩级别 （1-12） */
compression: number }

export interface ImageQuantOptions {
  minQuality: number
  maxQuality: number
  speed: number
  minPosterization: number
  dithering: number
  gamma: number
  lastIndexTransparent: boolean
}

export declare function initCustomTraceSubscriber(traceOutFilePath?: string | undefined | null): void

export declare const enum Interlacing {
  None = 'None',
  Adam7 = 'Adam7'
}

export declare const enum Kind {
  jpeg = 'jpeg',
  png = 'png',
  gif = 'gif',
  webp = 'webp',
  avif = 'avif',
  unknown = 'unknown'
}

export interface MozJpegOptions {
  /** 质量, 推荐 60-80. 范围：`1..=100` */
  quality: number
  /** 设置图像的渐进模式 */
  progressive: boolean
  /** 设置为 false 可以毫无理由地使文件变大 */
  optimizeCoding: boolean
  /** 非 0 （1..=100） 它将使用MozJPEG的平滑。 */
  smoothing: number
  /** 设置正在写入的 JPEG 的颜色空间，不同于输入的颜色空间 */
  colorSpace: ColorSpace
  /** 指定在网格量化期间是否应考虑多次扫描。 */
  trellisMultipass: boolean
  /** 设置色度子采样，保留为“None”以使用自动子采样 */
  chromaSubsample?: number
  /** 是否使用特定的量化表。替代质量（quality）设置。 */
  luma: boolean
  /** 是否使用特定的量化表的颜色。替代质量（quality）设置。 */
  chroma: boolean
  qtable?: QtableOptimize
}

export interface OxiPngOptions {
  /** fix_errors: bool:               尝试在解码输入文件时修复错误，而不是返回 `Err`。默认值: `false` */
  fixErrors: boolean
  /** force: bool:                    即使压缩没有改进，也写入输出。默认值: `false` */
  force: boolean
  /** filter: IndexSet<RowFilter>:    尝试在文件上使用哪些 RowFilters。默认值: `None,Sub,Entropy,Bigrams` */
  filter: RowFilter
  /** interlace: Option<Interlacing>: 是否更改文件的交错类型。`None` 将不会更改当前的交错类型。`Some(x)` 将把文件更改为交错模式 `x`。默认值: `Some(Interlacing::None)` */
  interlace?: Interlacing
  /** optimize_alpha: bool:           是否允许更改透明像素以提高压缩率。 */
  optimizeAlpha: boolean
  /** bit_depth_reduction: bool:      是否尝试位深度减少。默认值: `true` */
  bitDepthReduction: boolean
  /** color_type_reduction: bool:     是否尝试颜色类型减少。默认值: `true` */
  colorTypeReduction: boolean
  /** palette_reduction: bool:        是否尝试调色板减少。默认值: `true` */
  paletteReduction: boolean
  /** grayscale_reduction: bool:      是否尝试灰度减少。默认值: `true` */
  grayscaleReduction: boolean
  /** idat_recoding: bool:            是否对 IDAT 和其他压缩块进行重新编码。如果执行任何类型的减少，将无视此设置执行 IDAT 重新编码。默认值: `true` */
  idatRecoding: boolean
  /** scale_16: bool:                 是否强制将 16 位缩减为 8 位。默认值: `false` */
  scale16: boolean
  /** strip: StripChunks:             从 PNG 文件中剥离哪些块（如果有的话）。默认值: `None` */
  strip: StripChunks
  /** deflate: Deflaters:             使用哪种 DEFLATE 算法。默认值: `Libdeflater` */
  deflate: Deflaters
  /** fast_evaluation: bool:          是否使用快速评估来选择最佳过滤器。默认值: `true` */
  fastEvaluation: boolean
  /** timeout: Option<Duration>:      优化的最大时间。如果超时，将跳过进一步的潜在优化。 */
  timeout?: bigint
}

export declare const enum QtableOptimize {
  AhumadaWatsonPeterson = 'AhumadaWatsonPeterson',
  AnnexK_Luma = 'AnnexK_Luma',
  Flat = 'Flat',
  KleinSilversteinCarney = 'KleinSilversteinCarney',
  MSSSIM_Luma = 'MSSSIM_Luma',
  NRobidoux = 'NRobidoux',
  PSNRHVS_Luma = 'PSNRHVS_Luma',
  PetersonAhumadaWatson = 'PetersonAhumadaWatson',
  WatsonTaylorBorthwick = 'WatsonTaylorBorthwick'
}

export declare const enum RowFilter {
  None = 'None',
  Sub = 'Sub',
  Up = 'Up',
  Average = 'Average',
  Paeth = 'Paeth',
  MinSum = 'MinSum',
  Entropy = 'Entropy',
  Bigrams = 'Bigrams',
  BigEnt = 'BigEnt',
  Brute = 'Brute'
}

| { type2: 'None' }
| { type2: 'Strip', field0: unknown[] }
| { type2: 'Safe' }
| { type2: 'Keep', field0: unknown[] }
| { type2: 'All' }

export declare const enum WebPImageHint {
  WEBP_HINT_DEFAULT = 0,
  WEBP_HINT_PICTURE = 1,
  WEBP_HINT_PHOTO = 2,
  WEBP_HINT_GRAPH = 3,
  WEBP_HINT_LAST = 4
}

export interface WebPOptions {
  lossless: number
  quality: number
  method: number
  imageHint: WebPImageHint
  targetSize: number
  targetPsnr: number
  segments: number
  snsStrength: number
  filterStrength: number
  filterSharpness: number
  filterType: number
  autofilter: number
  alphaCompression: number
  alphaFiltering: number
  alphaQuality: number
  pass: number
  showCompressed: number
  preprocessing: number
  partitions: number
  partitionLimit: number
  emulateJpegSize: number
  threadLevel: number
  lowMemory: number
  nearLossless: number
  exact: number
  useDeltaPalette: number
  useSharpYuv: number
  qmin: number
  qmax: number
}

